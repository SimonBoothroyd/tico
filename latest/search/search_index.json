{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"tico <p>Torch-based internal coordinate geometry optimization.</p> <p> </p> <p>The <code>tico</code> framework provides utilities for optimizing the geometry of molecules in internal coordinates. It is heavily based off of geomeTRIC, but aims to improve the performance using PyTorch, and bypassing some of the QA checks. For a more robust option, consider using geomeTRIC instead.</p> <p>Because <code>tico</code> is heavily based off of <code>geomeTRIC</code>, please consider citing the original package if you use <code>tico</code> in your work:</p> <pre><code>@article{wang2016geometry,\n  title={Geometry optimization made simple with translation and rotation coordinates},\n  author={Wang, Lee-Ping and Song, Chenchen},\n  journal={The Journal of chemical physics},\n  volume={144},\n  number={21},\n  year={2016},\n  publisher={AIP Publishing}\n}\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>This package can be installed using <code>conda</code> (or <code>mamba</code>, a faster version of <code>conda</code>):</p> <pre><code>mamba install -c conda-forge tico\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To optimize the geometry of a molecule, you can use <code>tico.opt.optimize</code>. This takes as input and initial set of cartesian coordinates, and a function that returns the energy and gradient of the molecule at a given coordinate.</p> <p>Creating a molecule to optimize can be easily done using the <code>openff.toolkit</code> package:</p> <pre><code>import openff.toolkit\nimport torch\n\nff = openff.toolkit.ForceField(\"openff_unconstrained-2.1.0.offxml\")\n\nmol = openff.toolkit.Molecule.from_smiles(\"CCO\")\nmol.generate_conformers(n_conformers=1)\n\nbond_idxs = torch.tensor(\n    [[bond.atom1_index, bond.atom2_index] for bond in mol.bonds]\n)\natomic_nums = torch.tensor([atom.atomic_number for atom in mol.atoms])\n\ncoords_x = torch.tensor(mol.conformers[0].m_as(\"bohr\").tolist()).double()\n</code></pre> <p>An internal coordinate representation of the molecule can be created using the <code>tico.ic</code>:</p> <pre><code>import tico.ic\n\n# Create a primitive internal coordinates representation\nic = tico.ic.RIC.from_coords(coords_x, bond_idxs)\n# Or a usually more efficient delocalized internal coordinates representation\nic = tico.ic.DLC.from_coords(coords_x, bond_idxs)\n\n# If using the delocalized internal coordinates, optional constraints can be added.\n# For example, to fix the distance between atoms 0 and 1 to 2.0 bohr:\nconstr = {tico.ic.ICType.DISTANCE: (torch.tensor([[0, 1]]), torch.tensor([2.0]))}\nic = tico.ic.DLC.from_coords(coords_x, bond_idxs, constr)\n</code></pre> <p>An example energy function that uses OpenMM may look like:</p> <pre><code>import openmm\nimport openmm.unit\nimport torch\n\ndef create_energy_fn(context: openmm.Context):\n    def energy_fn(coords):\n        coords = coords.numpy().reshape(-1, 3) * openmm.unit.bohr\n        context.setPositions(coords)\n\n        state = context.getState(getEnergy=True, getForces=True)\n\n        energy = state.getPotentialEnergy() / openmm.unit.AVOGADRO_CONSTANT_NA\n        gradient = -state.getForces(asNumpy=True) / openmm.unit.AVOGADRO_CONSTANT_NA\n\n        energy = energy.value_in_unit(openmm.unit.hartree)\n        gradient = gradient.value_in_unit(\n            openmm.unit.hartree / openmm.unit.bohr\n        ).flatten()\n\n        return torch.tensor(energy), torch.tensor(gradient)\n\n    return energy_fn\n\nsystem = ff.create_openmm_system(mol.to_topology())\n\ncontext = openmm.Context(\n    system,\n    openmm.VerletIntegrator(1.0),\n    openmm.Platform.getPlatformByName(\"Reference\"),\n)\n\nenergy_fn = create_energy_fn(context)\n</code></pre> <p>where here the actual energy function is wrapped in a function that takes an <code>openmm.Context</code> as input for convenience.</p> <p>The optimization can then be performed using:</p> <pre><code>import tico.opt\n\nhistory, converged = tico.opt.optimize(coords_x, ic, energy_fn, atomic_nums)\nassert converged\n\ncoords_x_final = history[-1].coords_x\n</code></pre>"},{"location":"#license","title":"License","text":"<p>The main package is release under the MIT license. Parts of the package are largely inspired by geomeTRIC, see the LICENSE-3RD-PARTY file for the license of the original code.</p>"},{"location":"development/","title":"Development","text":"<p>To create a development environment, you must have <code>mamba</code> installed.</p> <p>A development conda environment can be created and activated with:</p> <pre><code>make env\nconda activate tico\n</code></pre> <p>To format the codebase:</p> <pre><code>make format\n</code></pre> <p>To run the unit tests:</p> <pre><code>make test\n</code></pre> <p>To serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#tico","title":"tico","text":"<p>Torch-based internal coordinate geometry optimization.</p> <p>Modules:</p> <ul> <li> <code>hess</code>         \u2013          <p>Utilities for approximating Hessian matrices.</p> </li> <li> <code>ic</code>         \u2013          <p>Compute internal coordinate representations of molecules.</p> </li> <li> <code>opt</code>         \u2013          <p>Optimize molecule geometrics in internal coordinates.</p> </li> <li> <code>tests</code>         \u2013          </li> <li> <code>utils</code>         \u2013          <p>Common utility functions.</p> </li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>tico<ul> <li>hess</li> <li>ic</li> <li>opt</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/hess/","title":"hess","text":""},{"location":"reference/hess/#tico.hess","title":"hess","text":"<p>Utilities for approximating Hessian matrices.</p> References <ol> <li>Schlegel, Theor. Chim. Acta, 66, 333 (1984)</li> </ol> <p>Functions:</p> <ul> <li> <code>guess_hess_q</code>           \u2013            <p>Build a guess Hessian that roughly follows Schlegel's guidelines.</p> </li> </ul>"},{"location":"reference/hess/#tico.hess.guess_hess_q","title":"guess_hess_q","text":"<pre><code>guess_hess_q(\n    coords: Tensor, ic_idxs: ICDict, atomic_nums: Tensor\n) -&gt; Tensor\n</code></pre> <p>Build a guess Hessian that roughly follows Schlegel's guidelines.</p> Source code in <code>tico/hess.py</code> <pre><code>def guess_hess_q(\n    coords: torch.Tensor, ic_idxs: tico.ic.ICDict, atomic_nums: torch.Tensor\n) -&gt; torch.Tensor:\n    \"\"\"Build a guess Hessian that roughly follows Schlegel's guidelines.\"\"\"\n\n    hess_diag = []\n\n    bonds = {\n        tuple(sorted([int(idx_a), int(idx_b)]))\n        for idx_a, idx_b in ic_idxs[tico.ic.ICType.DISTANCE]\n    }\n\n    def is_bound(idx_a, idx_b):\n        return tuple(sorted([int(idx_a), int(idx_b)])) in bonds\n\n    for ic_type, idxs in ic_idxs.items():\n        if ic_type == tico.ic.ICType.DISTANCE:\n            hess_diag.extend(_guess_hess_distance(coords, atomic_nums, idxs))\n        elif ic_type in {tico.ic.ICType.ANGLE, tico.ic.ICType.LINEAR}:\n            hess_diag.extend(_guess_hess_angle(atomic_nums, idxs, is_bound))\n        elif ic_type == tico.ic.ICType.DIHEDRAL:\n            hess_diag.extend([0.023] * len(idxs))\n        elif ic_type == tico.ic.ICType.OUT_OF_PLANE:\n            hess_diag.extend(_guess_hess_out_of_plane(idxs, is_bound))\n        else:\n            raise NotImplementedError()\n\n    return torch.diag(torch.tensor(hess_diag, dtype=coords.dtype, device=coords.device))\n</code></pre>"},{"location":"reference/ic/","title":"ic","text":""},{"location":"reference/ic/#tico.ic","title":"ic","text":"<p>Compute internal coordinate representations of molecules.</p> Notes <ul> <li>This module is heavily inspired off of the <code>internal</code> module of <code>geomeTRIC</code>.   See the LICENSE-3RD-PARTY for license information.</li> </ul> <p>Classes:</p> <ul> <li> <code>ICType</code>         \u2013          <p>The supported primitive internal coordinate types.</p> </li> <li> <code>IC</code>         \u2013          <p>A base class for internal coordinate representations.</p> </li> <li> <code>RIC</code>         \u2013          <p>A redundant internal coordinate representation.</p> </li> <li> <code>DLC</code>         \u2013          <p>A delocalized internal coordinates representation</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>ICDict</code>         \u2013          <p>A dictionary of tensors partitioned by internal coordinate type.</p> </li> <li> <code>IC_ORDER</code>         \u2013          <p>The order that internal coordinate types appear in a flattened representation.</p> </li> <li> <code>ConstraintDict</code>         \u2013          <p>A dictionary of constraints for each type of internal coordinate. It is of the form</p> </li> </ul>"},{"location":"reference/ic/#tico.ic.ICDict","title":"ICDict  <code>module-attribute</code>","text":"<pre><code>ICDict = dict[ICType, Tensor]\n</code></pre> <p>A dictionary of tensors partitioned by internal coordinate type.</p>"},{"location":"reference/ic/#tico.ic.IC_ORDER","title":"IC_ORDER  <code>module-attribute</code>","text":"<pre><code>IC_ORDER = (DISTANCE, ANGLE, LINEAR, OUT_OF_PLANE, DIHEDRAL)\n</code></pre> <p>The order that internal coordinate types appear in a flattened representation.</p>"},{"location":"reference/ic/#tico.ic.ConstraintDict","title":"ConstraintDict  <code>module-attribute</code>","text":"<pre><code>ConstraintDict = dict[ICType, tuple[Tensor, Tensor]]\n</code></pre> <p>A dictionary of constraints for each type of internal coordinate. It is of the form <code>{ic_type: (idxs, values)}</code> where <code>idxs</code> is a tensor of the indices of the atoms involved in the internal coordinates to constrain and <code>values</code> is a tensor of the values of that the internal coordinate should be constrained at.</p>"},{"location":"reference/ic/#tico.ic.ICType","title":"ICType","text":"<p>             Bases: <code>Enum</code></p> <p>The supported primitive internal coordinate types.</p>"},{"location":"reference/ic/#tico.ic.IC","title":"IC  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A base class for internal coordinate representations.</p> <p>Methods:</p> <ul> <li> <code>compute_b</code>           \u2013            <p>Computes jacobian of the internal coordinates with respect to the cartesian</p> </li> <li> <code>compute_q</code>           \u2013            <p>Maps a set of cartesian coordinates to a set of internal coordinates.</p> </li> <li> <code>compute_dq</code>           \u2013            <p>Compute the difference between two sets of coordinates in terms of internal</p> </li> <li> <code>guess_hess_q</code>           \u2013            <p>Build an approximate Hessian that roughly follows Schlegel's guidelines.</p> </li> <li> <code>dq_to_x</code>           \u2013            <p>Perturb a set of cartesian coordinates by a set of internal coordinate</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>idxs</code>             (<code>ICDict</code>)         \u2013          <p>The indices of the atoms involved in each type of internal coordinate.</p> </li> </ul>"},{"location":"reference/ic/#tico.ic.IC.idxs","title":"idxs  <code>instance-attribute</code>","text":"<pre><code>idxs: ICDict\n</code></pre> <p>The indices of the atoms involved in each type of internal coordinate.</p>"},{"location":"reference/ic/#tico.ic.IC.compute_b","title":"compute_b  <code>abstractmethod</code>","text":"<pre><code>compute_b(coords_x: Tensor) -&gt; Tensor\n</code></pre> <p>Computes jacobian of the internal coordinates with respect to the cartesian coordinates.</p> <p>This is the B matrix in the Pulay-Fogarasi-Pulay approach.</p> <p>Parameters:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The coordinates with <code>shape=(n_atoms, 3)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The jacobian, with <code>shape=(n_ic, n_atoms * 3)</code>.</p> </li> </ul> Source code in <code>tico/ic.py</code> <pre><code>@abc.abstractmethod\ndef compute_b(self, coords_x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Computes jacobian of the internal coordinates with respect to the cartesian\n    coordinates.\n\n    This is the B matrix in the Pulay-Fogarasi-Pulay approach.\n\n    Args:\n        coords_x: The coordinates with ``shape=(n_atoms, 3)``.\n\n    Returns:\n        The jacobian, with ``shape=(n_ic, n_atoms * 3)``.\n    \"\"\"\n</code></pre>"},{"location":"reference/ic/#tico.ic.IC.compute_q","title":"compute_q  <code>abstractmethod</code>","text":"<pre><code>compute_q(coords_x: Tensor) -&gt; Tensor\n</code></pre> <p>Maps a set of cartesian coordinates to a set of internal coordinates.</p> <p>Parameters:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The coordinates with <code>shape=(n_atoms, 3)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The flattened internal coordinate values with <code>shape=(n_ic,)</code>.</p> </li> </ul> Source code in <code>tico/ic.py</code> <pre><code>@abc.abstractmethod\ndef compute_q(self, coords_x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Maps a set of cartesian coordinates to a set of internal coordinates.\n\n    Args:\n        coords_x: The coordinates with ``shape=(n_atoms, 3)``.\n\n    Returns:\n        The flattened internal coordinate values with ``shape=(n_ic,)``.\n    \"\"\"\n</code></pre>"},{"location":"reference/ic/#tico.ic.IC.compute_dq","title":"compute_dq  <code>abstractmethod</code>","text":"<pre><code>compute_dq(\n    coords_x_a: Tensor, coords_x_b: Tensor\n) -&gt; Tensor\n</code></pre> <p>Compute the difference between two sets of coordinates in terms of internal coordinates.</p> <p>Parameters:</p> <ul> <li> <code>coords_x_a</code>             (<code>Tensor</code>)         \u2013          <p>The first coordinates with <code>shape=(n_atoms, 3)</code>.</p> </li> <li> <code>coords_x_b</code>             (<code>Tensor</code>)         \u2013          <p>The second coordinates with <code>shape=(n_atoms, 3)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The internal coordinate displacements with <code>shape=(n_ic,)</code>.</p> </li> </ul> Source code in <code>tico/ic.py</code> <pre><code>@abc.abstractmethod\ndef compute_dq(\n    self, coords_x_a: torch.Tensor, coords_x_b: torch.Tensor\n) -&gt; torch.Tensor:\n    \"\"\"Compute the difference between two sets of coordinates in terms of internal\n    coordinates.\n\n    Args:\n        coords_x_a: The first coordinates with ``shape=(n_atoms, 3)``.\n        coords_x_b: The second coordinates with ``shape=(n_atoms, 3)``.\n\n    Returns:\n        The internal coordinate displacements with ``shape=(n_ic,)``.\n    \"\"\"\n</code></pre>"},{"location":"reference/ic/#tico.ic.IC.guess_hess_q","title":"guess_hess_q  <code>abstractmethod</code>","text":"<pre><code>guess_hess_q(\n    coords_x: Tensor, atomic_nums: Tensor\n) -&gt; Tensor\n</code></pre> <p>Build an approximate Hessian that roughly follows Schlegel's guidelines.</p> <p>Parameters:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The coordinates with <code>shape=(n_atoms, 3)</code>.</p> </li> <li> <code>atomic_nums</code>             (<code>Tensor</code>)         \u2013          <p>The atomic number of each atom with <code>shape=(n_atoms,)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The approximate Hessian with <code>shape=(n_ic, n_ic)</code>.</p> </li> </ul> Source code in <code>tico/ic.py</code> <pre><code>@abc.abstractmethod\ndef guess_hess_q(\n    self, coords_x: torch.Tensor, atomic_nums: torch.Tensor\n) -&gt; torch.Tensor:\n    \"\"\"Build an approximate Hessian that roughly follows Schlegel's guidelines.\n\n    Args:\n        coords_x: The coordinates with ``shape=(n_atoms, 3)``.\n        atomic_nums: The atomic number of each atom with ``shape=(n_atoms,)``.\n\n    Returns:\n        The approximate Hessian with ``shape=(n_ic, n_ic)``.\n    \"\"\"\n</code></pre>"},{"location":"reference/ic/#tico.ic.IC.dq_to_x","title":"dq_to_x  <code>abstractmethod</code>","text":"<pre><code>dq_to_x(\n    coords_x: Tensor, dq: Tensor\n) -&gt; tuple[Tensor, Tensor, bool]\n</code></pre> <p>Perturb a set of cartesian coordinates by a set of internal coordinate displacements.</p> <p>Parameters:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The coordinates with <code>shape=(n_atoms, 3)</code>.</p> </li> <li> <code>dq</code>             (<code>Tensor</code>)         \u2013          <p>The internal coordinate displacements with <code>shape=(n_ic,)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Tensor, Tensor, bool]</code>         \u2013          <p>The perturbed cartesian (with <code>shape=(n_atoms, 3)</code>) and internal coordinates (with <code>shape=(n_ic,)</code>), and a boolean indicating whether the perturbation was successful.</p> </li> </ul> Source code in <code>tico/ic.py</code> <pre><code>@abc.abstractmethod\ndef dq_to_x(\n    self, coords_x: torch.Tensor, dq: torch.Tensor\n) -&gt; tuple[torch.Tensor, torch.Tensor, bool]:\n    \"\"\"Perturb a set of cartesian coordinates by a set of internal coordinate\n    displacements.\n\n    Args:\n        coords_x: The coordinates with ``shape=(n_atoms, 3)``.\n        dq: The internal coordinate displacements with ``shape=(n_ic,)``.\n\n    Returns:\n        The perturbed cartesian (with ``shape=(n_atoms, 3)``) and internal\n        coordinates (with ``shape=(n_ic,)``), and a boolean indicating whether the\n        perturbation was successful.\n    \"\"\"\n</code></pre>"},{"location":"reference/ic/#tico.ic.RIC","title":"RIC  <code>dataclass</code>","text":"<p>             Bases: <code>IC</code></p> <p>A redundant internal coordinate representation.</p> <p>Methods:</p> <ul> <li> <code>from_coords</code>           \u2013            <p>Projects a set of cartesian coordinates onto a reduced set of delocalized</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>idxs</code>             (<code>ICDict</code>)         \u2013          <p>The indices of the atoms involved in each type of internal coordinate.</p> </li> </ul>"},{"location":"reference/ic/#tico.ic.RIC.idxs","title":"idxs  <code>instance-attribute</code>","text":"<pre><code>idxs: ICDict\n</code></pre> <p>The indices of the atoms involved in each type of internal coordinate.</p>"},{"location":"reference/ic/#tico.ic.RIC.from_coords","title":"from_coords  <code>classmethod</code>","text":"<pre><code>from_coords(coords_x: Tensor, bond_idxs: Tensor) -&gt; RIC\n</code></pre> <p>Projects a set of cartesian coordinates onto a reduced set of delocalized internal coordinates.</p> <p>Parameters:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The coordinates with <code>shape=(n_atoms, 3)</code>.</p> </li> <li> <code>bond_idxs</code>             (<code>Tensor</code>)         \u2013          <p>The atoms involved in each bond with <code>shape=(n_bonds, 2)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RIC</code>         \u2013          <p>The internal coordinate representation.</p> </li> </ul> Source code in <code>tico/ic.py</code> <pre><code>@classmethod\ndef from_coords(cls, coords_x: torch.Tensor, bond_idxs: torch.Tensor) -&gt; \"RIC\":\n    \"\"\"Projects a set of cartesian coordinates onto a reduced set of delocalized\n    internal coordinates.\n\n    Args:\n        coords_x: The coordinates with ``shape=(n_atoms, 3)``.\n        bond_idxs: The atoms involved in each bond with ``shape=(n_bonds, 2)``.\n\n    Returns:\n        The internal coordinate representation.\n    \"\"\"\n    coords_x = coords_x.double()\n\n    graph = networkx.Graph(bond_idxs.detach().tolist())\n\n    angle_idxs, linear_angle_idxs = _detect_angles(coords_x, graph)\n    angle_idxs, out_of_plane_idxs = _detect_out_of_plane_angles(\n        coords_x, graph, angle_idxs\n    )\n\n    dihedral_idxs = _detect_dihedrals(coords_x, graph, linear_angle_idxs)\n\n    return_value = {\n        ICType.DISTANCE: bond_idxs,\n        ICType.ANGLE: angle_idxs,\n        ICType.LINEAR: linear_angle_idxs,\n        ICType.OUT_OF_PLANE: out_of_plane_idxs,\n        ICType.DIHEDRAL: dihedral_idxs,\n    }\n    return RIC(\n        {key: value for key, value in return_value.items() if len(value) &gt; 0}\n    )\n</code></pre>"},{"location":"reference/ic/#tico.ic.DLC","title":"DLC  <code>dataclass</code>","text":"<p>             Bases: <code>IC</code></p> <p>A delocalized internal coordinates representation</p> <p>Methods:</p> <ul> <li> <code>from_coords</code>           \u2013            <p>Projects a set of cartesian coordinates onto a reduced set of delocalized</p> </li> <li> <code>compute_constr_delta</code>           \u2013            <p>Compute the difference between the current internal coordinate values and the</p> </li> <li> <code>augment_hess_q</code>           \u2013            <p>Augment a hessian with extra dimensions corresponding to the constrained</p> </li> <li> <code>project_grad_x</code>           \u2013            <p>Project out the components of the internal coordinate gradient along the</p> </li> <li> <code>enforce_constraints</code>           \u2013            <p>Modify cartesian coordinates to enforce any internal coordinate constraints.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>idxs</code>             (<code>ICDict</code>)         \u2013          <p>The indices of the atoms involved in each type of internal coordinate.</p> </li> <li> <code>v</code>             (<code>Tensor</code>)         \u2013          <p>The projection of RIC onto the non-redundant basis.</p> </li> <li> <code>constr</code>             (<code>ConstraintDict | None</code>)         \u2013          <p>Constraints on the internal coordinates.</p> </li> </ul>"},{"location":"reference/ic/#tico.ic.DLC.idxs","title":"idxs  <code>instance-attribute</code>","text":"<pre><code>idxs: ICDict\n</code></pre> <p>The indices of the atoms involved in each type of internal coordinate.</p>"},{"location":"reference/ic/#tico.ic.DLC.v","title":"v  <code>instance-attribute</code>","text":"<pre><code>v: Tensor\n</code></pre> <p>The projection of RIC onto the non-redundant basis.</p>"},{"location":"reference/ic/#tico.ic.DLC.constr","title":"constr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>constr: ConstraintDict | None = None\n</code></pre> <p>Constraints on the internal coordinates.</p>"},{"location":"reference/ic/#tico.ic.DLC.from_coords","title":"from_coords  <code>classmethod</code>","text":"<pre><code>from_coords(\n    coords_x: Tensor,\n    bond_idxs: Tensor,\n    constr: ConstraintDict | None = None,\n) -&gt; DLC\n</code></pre> <p>Projects a set of cartesian coordinates onto a reduced set of delocalized internal coordinates.</p> <p>Parameters:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The coordinates with shape=(n_atoms, 3).</p> </li> <li> <code>bond_idxs</code>             (<code>Tensor</code>)         \u2013          <p>The atoms involved in each bond with shape=(n_bonds, 2).</p> </li> <li> <code>constr</code>             (<code>ConstraintDict | None</code>, default:                 <code>None</code> )         \u2013          <p>A dictionary of constraints on the internal coordinates. This dictionary should be of the form <code>constr[ic_type] = (idxs, values)</code> where <code>idxs</code> is a tensor of the indices of the atoms involved in the internal coordinate and <code>values</code> is a tensor of the values to constrain the internal coordinate at.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DLC</code>         \u2013          <p>The internal coordinate representation.</p> </li> </ul> Source code in <code>tico/ic.py</code> <pre><code>@classmethod\ndef from_coords(\n    cls,\n    coords_x: torch.Tensor,\n    bond_idxs: torch.Tensor,\n    constr: ConstraintDict | None = None,\n) -&gt; \"DLC\":\n    \"\"\"Projects a set of cartesian coordinates onto a reduced set of delocalized\n    internal coordinates.\n\n    Args:\n        coords_x: The coordinates with shape=(n_atoms, 3).\n        bond_idxs: The atoms involved in each bond with shape=(n_bonds, 2).\n        constr: A dictionary of constraints on the internal coordinates. This\n            dictionary should be of the form ``constr[ic_type] = (idxs, values)``\n            where ``idxs`` is a tensor of the indices of the atoms involved in the\n            internal coordinate and ``values`` is a tensor of the values to\n            constrain the internal coordinate at.\n\n    Returns:\n        The internal coordinate representation.\n    \"\"\"\n    coords_x = coords_x.double()\n\n    ric = RIC.from_coords(coords_x, bond_idxs)\n\n    b_matrix = ric.compute_b(coords_x)\n    g_matrix = b_matrix @ b_matrix.T\n\n    eig_vals, eig_vecs = torch.linalg.eigh(g_matrix)\n    eig_mask = torch.abs(eig_vals) &gt; 1e-6\n\n    v = eig_vecs[:, eig_mask]\n\n    if constr is not None and len(constr) == 0:\n        constr = None\n    if constr is not None:\n        v = cls._project_constr(v, constr, ric)\n\n    return cls(ric.idxs, v, constr)\n</code></pre>"},{"location":"reference/ic/#tico.ic.DLC.compute_constr_delta","title":"compute_constr_delta","text":"<pre><code>compute_constr_delta(coords_x: Tensor) -&gt; Tensor\n</code></pre> <p>Compute the difference between the current internal coordinate values and the constrained values.</p> Source code in <code>tico/ic.py</code> <pre><code>def compute_constr_delta(self, coords_x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Compute the difference between the current internal coordinate values and the\n    constrained values.\"\"\"\n    constr_idxs = {ic_type: idxs for ic_type, (idxs, _) in self.constr.items()}\n    constr_vals = {ic_type: vals for ic_type, (_, vals) in self.constr.items()}\n\n    coords_q = _compute_q(coords_x, constr_idxs)\n\n    return _compute_dq(constr_vals, coords_q)\n</code></pre>"},{"location":"reference/ic/#tico.ic.DLC.augment_hess_q","title":"augment_hess_q","text":"<pre><code>augment_hess_q(\n    coords_x: Tensor, grad_q: Tensor, hess_q: Tensor\n)\n</code></pre> <p>Augment a hessian with extra dimensions corresponding to the constrained DoF.</p> <p>Parameters:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The coordinates with <code>shape=(n_atoms, 3)</code>.</p> </li> <li> <code>grad_q</code>             (<code>Tensor</code>)         \u2013          <p>The gradient of the internal coordinates with <code>shape=(n_ic,)</code>.</p> </li> <li> <code>hess_q</code>             (<code>Tensor</code>)         \u2013          <p>The hessian of the internal coordinates with <code>shape=(n_ic, n_ic)</code>.</p> </li> </ul> Source code in <code>tico/ic.py</code> <pre><code>def augment_hess_q(\n    self, coords_x: torch.Tensor, grad_q: torch.Tensor, hess_q: torch.Tensor\n):\n    \"\"\"Augment a hessian with extra dimensions corresponding to the constrained\n    DoF.\n\n    Args:\n        coords_x: The coordinates with ``shape=(n_atoms, 3)``.\n        grad_q: The gradient of the internal coordinates with ``shape=(n_ic,)``.\n        hess_q: The hessian of the internal coordinates with ``shape=(n_ic, n_ic)``.\n    \"\"\"\n\n    constr_to_ic_idx = _match_constr(self.constr, self.idxs)\n\n    ni = len(grad_q)\n    nc = len(constr_to_ic_idx)\n\n    diag_idxs = list(range(len(constr_to_ic_idx)))\n\n    ct = smee.utils.zeros_like((nc, ni), coords_x)\n    ct[diag_idxs, diag_idxs] = 1.0 / self.v[constr_to_ic_idx, diag_idxs]\n\n    nt = ni + nc\n\n    constr_diff = -self.compute_constr_delta(coords_x)\n    # au/rad (about 0.16 A / 17 deg)\n    # constr_diff[:nc] = torch.clamp(constr_diff[:nc], -0.3, 0.3)\n\n    hess_q_constr = smee.utils.zeros_like((nt, nt), coords_x)\n    hess_q_constr[0:ni, 0:ni] = hess_q[:, :]\n    hess_q_constr[ni:nt, 0:ni] = ct[:, :]\n    hess_q_constr[0:ni, ni:nt] = ct.T[:, :]\n\n    grad_q_constr = smee.utils.zeros_like(nt, coords_x)\n    grad_q_constr[0:ni] = grad_q[:]\n    grad_q_constr[ni:nt] = -constr_diff[:]\n\n    return grad_q_constr, hess_q_constr\n</code></pre>"},{"location":"reference/ic/#tico.ic.DLC.project_grad_x","title":"project_grad_x","text":"<pre><code>project_grad_x(coords_x: Tensor, grad_x: Tensor) -&gt; Tensor\n</code></pre> <p>Project out the components of the internal coordinate gradient along the constrained degrees of freedom.</p> Source code in <code>tico/ic.py</code> <pre><code>def project_grad_x(\n    self, coords_x: torch.Tensor, grad_x: torch.Tensor\n) -&gt; torch.Tensor:\n    \"\"\"Project out the components of the internal coordinate gradient along the\n    constrained degrees of freedom.\"\"\"\n\n    if self.constr is None:\n        return grad_x\n\n    b_matrix = self.compute_b(coords_x)\n    g_matrix_inv = tico.utils.pinv(b_matrix @ b_matrix.T)\n\n    n_constr = sum(len(v) for i, v in self.constr.values())\n\n    grad_q = torch.linalg.multi_dot([g_matrix_inv, b_matrix, grad_x])\n    grad_q[:n_constr] = 0.0\n\n    return torch.linalg.multi_dot([b_matrix.T, grad_q])\n</code></pre>"},{"location":"reference/ic/#tico.ic.DLC.enforce_constraints","title":"enforce_constraints","text":"<pre><code>enforce_constraints(\n    coords_x: Tensor, tol: float = 1e-06\n) -&gt; tuple[Tensor, Tensor, bool]\n</code></pre> <p>Modify cartesian coordinates to enforce any internal coordinate constraints.</p> <p>Parameters:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The coordinates with shape=(n_atoms, 3).</p> </li> <li> <code>tol</code>             (<code>float</code>, default:                 <code>1e-06</code> )         \u2013          <p>The tolerance for the constraint satisfaction.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Tensor, Tensor, bool]</code>         \u2013          <p>The modified coordinates and internal coordinates, and a boolean indicating whether the conversion of cartesian to internal coordinates was successful.</p> </li> </ul> Source code in <code>tico/ic.py</code> <pre><code>def enforce_constraints(\n    self, coords_x: torch.Tensor, tol: float = 1e-6\n) -&gt; tuple[torch.Tensor, torch.Tensor, bool]:\n    \"\"\"Modify cartesian coordinates to enforce any internal coordinate constraints.\n\n    Args:\n        coords_x: The coordinates with shape=(n_atoms, 3).\n        tol: The tolerance for the constraint satisfaction.\n\n    Returns:\n        The modified coordinates and internal coordinates, and a boolean indicating\n        whether the conversion of cartesian to internal coordinates was successful.\n    \"\"\"\n    iteration = 0\n\n    constr_to_ic_idx = _match_constr(self.constr, self.idxs)\n\n    dq_norm = 0.0\n    dq_norm_best, soln_best = None, None\n\n    while True:\n        dq = smee.utils.zeros_like(self.v.shape[-1], self.v)\n\n        # because of how we construct v, the first n_v columns should be the\n        # projected constrained DoF\n        constr_delta = -self.compute_constr_delta(coords_x)\n\n        dq[: len(constr_delta)] = constr_delta\n        dq[: len(constr_delta)] /= self.v[\n            constr_to_ic_idx, list(range(len(constr_delta)))\n        ]\n\n        dq_norm_prev = dq_norm\n        dq_norm = torch.linalg.norm(dq)\n\n        soln = self.dq_to_x(coords_x, dq, enforce_constr=False)\n        coords_x = soln[0]\n\n        if dq_norm_best is None or dq_norm &lt; dq_norm_best:\n            dq_norm_best, soln_best = dq_norm, soln\n\n        if dq_norm &lt; tol:\n            return soln\n\n        if iteration &gt; 0 and dq_norm &gt; dq_norm_prev:\n            _LOGGER.warning(\"constraint satisfaction failed to converge\")\n            return soln_best\n\n        iteration += 1\n</code></pre>"},{"location":"reference/opt/","title":"opt","text":""},{"location":"reference/opt/#tico.opt","title":"opt","text":"<p>Optimize molecule geometrics in internal coordinates.</p> Notes <ul> <li>This module is heavily inspired off of the <code>optimize</code> and <code>step</code> modules of   <code>geomeTRIC</code>. See the LICENSE-3RD-PARTY for license information.</li> </ul> <p>Classes:</p> <ul> <li> <code>Step</code>         \u2013          <p>The outputs of step in the optimization process.</p> </li> <li> <code>ConvergenceCriteria</code>         \u2013          <p>The convergence criteria for the optimization process.</p> </li> <li> <code>Params</code>         \u2013          <p>Parameters for the optimization process.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>optimize</code>           \u2013            <p>Optimize the geometry of a molecule.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>CONVERGENCE_CRITERIA</code>             (<code>dict[str, ConvergenceCriteria]</code>)         \u2013          <p>Default convergence criteria for optimization.</p> </li> </ul>"},{"location":"reference/opt/#tico.opt.CONVERGENCE_CRITERIA","title":"CONVERGENCE_CRITERIA  <code>module-attribute</code>","text":"<pre><code>CONVERGENCE_CRITERIA: dict[str, ConvergenceCriteria] = {\n    \"GAU\": {\n        \"energy\": 1e-06,\n        \"rms_grad\": 0.0003,\n        \"max_grad\": 0.00045,\n        \"rms_disp\": 0.0012 * _ANGSTROM_TO_BOHR,\n        \"max_disp\": 0.0018 * _ANGSTROM_TO_BOHR,\n    },\n    \"GAU_LOOSE\": {\n        \"energy\": 1e-06,\n        \"rms_grad\": 0.0017,\n        \"max_grad\": 0.0025,\n        \"rms_disp\": 0.0067 * _ANGSTROM_TO_BOHR,\n        \"max_disp\": 0.01 * _ANGSTROM_TO_BOHR,\n    },\n    \"GAU_TIGHT\": {\n        \"energy\": 1e-06,\n        \"rms_grad\": 1e-05,\n        \"max_grad\": 1.5e-05,\n        \"rms_disp\": 4e-05 * _ANGSTROM_TO_BOHR,\n        \"max_disp\": 6e-05 * _ANGSTROM_TO_BOHR,\n    },\n}\n</code></pre> <p>Default convergence criteria for optimization.</p>"},{"location":"reference/opt/#tico.opt.Step","title":"Step","text":"<p>             Bases: <code>NamedTuple</code></p> <p>The outputs of step in the optimization process.</p> <p>Attributes:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The cartesian coordinates.</p> </li> <li> <code>grad_x</code>             (<code>Tensor</code>)         \u2013          <p>The gradients in cartesian coordinates.</p> </li> <li> <code>coords_q</code>             (<code>Tensor</code>)         \u2013          <p>The internal coordinates.</p> </li> <li> <code>grad_q</code>             (<code>Tensor</code>)         \u2013          <p>The gradients in internal coordinates.</p> </li> </ul>"},{"location":"reference/opt/#tico.opt.Step.coords_x","title":"coords_x  <code>instance-attribute</code>","text":"<pre><code>coords_x: Tensor\n</code></pre> <p>The cartesian coordinates.</p>"},{"location":"reference/opt/#tico.opt.Step.grad_x","title":"grad_x  <code>instance-attribute</code>","text":"<pre><code>grad_x: Tensor\n</code></pre> <p>The gradients in cartesian coordinates.</p>"},{"location":"reference/opt/#tico.opt.Step.coords_q","title":"coords_q  <code>instance-attribute</code>","text":"<pre><code>coords_q: Tensor\n</code></pre> <p>The internal coordinates.</p>"},{"location":"reference/opt/#tico.opt.Step.grad_q","title":"grad_q  <code>instance-attribute</code>","text":"<pre><code>grad_q: Tensor\n</code></pre> <p>The gradients in internal coordinates.</p>"},{"location":"reference/opt/#tico.opt.ConvergenceCriteria","title":"ConvergenceCriteria","text":"<p>             Bases: <code>TypedDict</code></p> <p>The convergence criteria for the optimization process.</p> <p>Attributes:</p> <ul> <li> <code>energy</code>             (<code>float</code>)         \u2013          <p>The energy [Eh] convergence criteria.</p> </li> <li> <code>rms_grad</code>             (<code>float</code>)         \u2013          <p>The root mean square of the gradients [Eh/Bohr] convergence criteria.</p> </li> <li> <code>max_grad</code>             (<code>float</code>)         \u2013          <p>The maximum gradient [Eh/Bohr] convergence criteria.</p> </li> <li> <code>rms_disp</code>             (<code>float</code>)         \u2013          <p>The root mean square of the displacements [Bohr] convergence criteria.</p> </li> <li> <code>max_disp</code>             (<code>float</code>)         \u2013          <p>The maximum displacement [Bohr] convergence criteria.</p> </li> </ul>"},{"location":"reference/opt/#tico.opt.ConvergenceCriteria.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy: float\n</code></pre> <p>The energy [Eh] convergence criteria.</p>"},{"location":"reference/opt/#tico.opt.ConvergenceCriteria.rms_grad","title":"rms_grad  <code>instance-attribute</code>","text":"<pre><code>rms_grad: float\n</code></pre> <p>The root mean square of the gradients [Eh/Bohr] convergence criteria.</p>"},{"location":"reference/opt/#tico.opt.ConvergenceCriteria.max_grad","title":"max_grad  <code>instance-attribute</code>","text":"<pre><code>max_grad: float\n</code></pre> <p>The maximum gradient [Eh/Bohr] convergence criteria.</p>"},{"location":"reference/opt/#tico.opt.ConvergenceCriteria.rms_disp","title":"rms_disp  <code>instance-attribute</code>","text":"<pre><code>rms_disp: float\n</code></pre> <p>The root mean square of the displacements [Bohr] convergence criteria.</p>"},{"location":"reference/opt/#tico.opt.ConvergenceCriteria.max_disp","title":"max_disp  <code>instance-attribute</code>","text":"<pre><code>max_disp: float\n</code></pre> <p>The maximum displacement [Bohr] convergence criteria.</p>"},{"location":"reference/opt/#tico.opt.Params","title":"Params  <code>dataclass</code>","text":"<p>Parameters for the optimization process.</p> <p>Attributes:</p> <ul> <li> <code>max_steps</code>             (<code>int</code>)         \u2013          <p>The maximum number of steps to take.</p> </li> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>The minimum eigenvalue of the Hessian.</p> </li> <li> <code>trust</code>             (<code>float</code>)         \u2013          <p>The initial trust radius. This will be adjusted during the optimization</p> </li> <li> <code>trust_min</code>             (<code>float</code>)         \u2013          <p>The lower bound of the trust radius.</p> </li> <li> <code>trust_max</code>             (<code>float</code>)         \u2013          <p>The upper bound of the trust radius.</p> </li> <li> <code>criteria</code>             (<code>ConvergenceCriteria</code>)         \u2013          <p>The convergence criteria to use.</p> </li> </ul>"},{"location":"reference/opt/#tico.opt.Params.max_steps","title":"max_steps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_steps: int = 300\n</code></pre> <p>The maximum number of steps to take.</p>"},{"location":"reference/opt/#tico.opt.Params.epsilon","title":"epsilon  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>epsilon: float = 1e-05\n</code></pre> <p>The minimum eigenvalue of the Hessian.</p>"},{"location":"reference/opt/#tico.opt.Params.trust","title":"trust  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trust: float = 0.1 * _ANGSTROM_TO_BOHR\n</code></pre> <p>The initial trust radius. This will be adjusted during the optimization process.</p>"},{"location":"reference/opt/#tico.opt.Params.trust_min","title":"trust_min  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trust_min: float = 0.0012 * _ANGSTROM_TO_BOHR\n</code></pre> <p>The lower bound of the trust radius.</p>"},{"location":"reference/opt/#tico.opt.Params.trust_max","title":"trust_max  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trust_max: float = 0.3 * _ANGSTROM_TO_BOHR\n</code></pre> <p>The upper bound of the trust radius.</p>"},{"location":"reference/opt/#tico.opt.Params.criteria","title":"criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>criteria: ConvergenceCriteria = field(\n    default_factory=lambda: {\n        None: CONVERGENCE_CRITERIA[\"GAU\"]\n    }\n)\n</code></pre> <p>The convergence criteria to use.</p>"},{"location":"reference/opt/#tico.opt.optimize","title":"optimize","text":"<pre><code>optimize(\n    coords_x: Tensor,\n    ic: IC,\n    energy_fn: EnergyFn,\n    atomic_nums: Tensor,\n    params: Params | None = None,\n) -&gt; tuple[list[Step], bool]\n</code></pre> <p>Optimize the geometry of a molecule.</p> <p>Parameters:</p> <ul> <li> <code>coords_x</code>             (<code>Tensor</code>)         \u2013          <p>The initial cartesian coordinates.</p> </li> <li> <code>ic</code>             (<code>IC</code>)         \u2013          <p>The internal coordinate representation of the molecule.</p> </li> <li> <code>energy_fn</code>             (<code>EnergyFn</code>)         \u2013          <p>A function that computes the energy and gradients of the molecule. It should take the cartesian coordinates and return the energy and gradients in atomic units.</p> </li> <li> <code>atomic_nums</code>             (<code>Tensor</code>)         \u2013          <p>The atomic numbers of the atoms in the molecule.</p> </li> <li> <code>params</code>             (<code>Params | None</code>, default:                 <code>None</code> )         \u2013          <p>The parameters for the optimization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list[Step], bool]</code>         \u2013          <p>The history of the optimization process and whether the optimization converged or not.</p> </li> </ul> Source code in <code>tico/opt.py</code> <pre><code>def optimize(\n    coords_x: torch.Tensor,\n    ic: tico.ic.IC,\n    energy_fn: EnergyFn,\n    atomic_nums: torch.Tensor,\n    params: Params | None = None,\n) -&gt; tuple[list[Step], bool]:\n    \"\"\"Optimize the geometry of a molecule.\n\n    Args:\n        coords_x: The initial cartesian coordinates.\n        ic: The internal coordinate representation of the molecule.\n        energy_fn: A function that computes the energy and gradients of the molecule.\n            It should take the cartesian coordinates and return the energy and\n            gradients in atomic units.\n        atomic_nums: The atomic numbers of the atoms in the molecule.\n        params: The parameters for the optimization.\n\n    Returns:\n        The history of the optimization process and whether the optimization converged\n        or not.\n    \"\"\"\n    params = params if params is not None else Params()\n\n    trust = params.trust\n    history = []\n\n    reject_step = False\n\n    coords_x = coords_x.double()\n    coords_q = ic.compute_q(coords_x)\n\n    hess_q = ic.guess_hess_q(coords_x, atomic_nums)\n    energy, grad_x = energy_fn(coords_x)\n\n    for _ in range(params.max_steps):\n        grad_q = _compute_grad_q(coords_x, grad_x, ic)\n\n        if not reject_step:\n            history.append(Step(coords_x, grad_x, coords_q, grad_q))\n            hess_q = tico.hess.update_hess_q(hess_q, history, ic)\n\n        min_eig_val = sorted(torch.linalg.eigh(hess_q)[0])[0].real\n        step_size = (\n            params.epsilon - min_eig_val if min_eig_val &lt; params.epsilon else 0.0\n        )\n\n        dq, _ = _compute_dq(step_size, coords_x, grad_q, hess_q, ic)\n        coords_x_new, coords_q_new, q_converged = ic.dq_to_x(coords_x, dq)\n\n        if tico.utils.compute_rmsd(coords_x_new, coords_x)[0] &gt; 1.1 * params.trust:\n            dq = _line_search(params.trust, step_size, coords_x, grad_q, hess_q, dq, ic)\n            coords_x_new, coords_q_new, q_converged = ic.dq_to_x(coords_x, dq)\n\n        energy_new, grad_x_new = energy_fn(coords_x_new)\n\n        rms_grad, max_grad = _compute_grad_norm(coords_x_new, grad_x_new, ic)\n        rms_disp, max_disp = tico.utils.compute_rmsd(coords_x_new, coords_x)\n\n        if _has_converged(\n            energy, energy_new, rms_grad, max_grad, rms_disp, max_disp, params\n        ):\n            grad_q_new = _compute_grad_q(coords_x, grad_x, ic)\n\n            history = history + [\n                Step(coords_x_new, grad_x_new, coords_q_new, grad_q_new)\n            ]\n            return history, True\n\n        expected_improve = float(\n            0.5 * torch.linalg.multi_dot([dq.unsqueeze(0), hess_q, dq])\n            + torch.dot(dq, grad_q)\n        )\n        step_quality = (energy_new - energy) / expected_improve\n\n        constr_violation = (\n            isinstance(ic, tico.ic.DLC)\n            and ic.constr is not None\n            and torch.max(torch.abs(ic.compute_constr_delta(coords_x_new))) &gt; 1e-1\n        )\n\n        trust, reject_step = _update_trust(\n            step_quality,\n            rms_disp,\n            torch.abs(energy_new - energy) &lt; params.criteria[\"energy\"],\n            trust,\n            params.trust_min,\n            params.trust_max,\n            constr_violation,\n        )\n\n        if not reject_step:\n            coords_x, coords_q = coords_x_new, coords_q_new\n            energy, grad_x = energy_new, grad_x_new\n\n    return history, False\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#tico.utils","title":"utils","text":"<p>Common utility functions.</p> <p>Functions:</p> <ul> <li> <code>pinv</code>           \u2013            <p>Invert a matrix using SVD.</p> </li> <li> <code>compute_rmsd</code>           \u2013            <p>Compute the RMSD and maximum displacement between two sets of coordinates.</p> </li> <li> <code>brent</code>           \u2013            <p>Find the root of a function using Brent's method.</p> </li> </ul>"},{"location":"reference/utils/#tico.utils.pinv","title":"pinv","text":"<pre><code>pinv(matrix: Tensor, threshold: float = 1e-06) -&gt; Tensor\n</code></pre> <p>Invert a matrix using SVD.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>             (<code>Tensor</code>)         \u2013          <p>The matrix to invert.</p> </li> <li> <code>threshold</code>             (<code>float</code>, default:                 <code>1e-06</code> )         \u2013          <p>Eigenvalues below this value will be ignored.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The inverted matrix.</p> </li> </ul> Source code in <code>tico/utils.py</code> <pre><code>def pinv(matrix: torch.Tensor, threshold: float = 1e-6) -&gt; torch.Tensor:\n    \"\"\"Invert a matrix using SVD.\n\n    Args:\n        matrix: The matrix to invert.\n        threshold: Eigenvalues below this value will be ignored.\n\n    Returns:\n        The inverted matrix.\n    \"\"\"\n    return torch.linalg.pinv(matrix, rtol=threshold, hermitian=True)\n</code></pre>"},{"location":"reference/utils/#tico.utils.compute_rmsd","title":"compute_rmsd","text":"<pre><code>compute_rmsd(\n    x: Tensor, y: Tensor, align: bool = True\n) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Compute the RMSD and maximum displacement between two sets of coordinates.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>Tensor</code>)         \u2013          <p>The first set of coordinates.</p> </li> <li> <code>y</code>             (<code>Tensor</code>)         \u2013          <p>The second set of coordinates.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Tensor, Tensor]</code>         \u2013          <p>The RMSD and maximum displacement.</p> </li> </ul> Source code in <code>tico/utils.py</code> <pre><code>def compute_rmsd(\n    x: torch.Tensor, y: torch.Tensor, align: bool = True\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"Compute the RMSD and maximum displacement between two sets of coordinates.\n\n    Args:\n        x: The first set of coordinates.\n        y: The second set of coordinates.\n\n    Returns:\n        The RMSD and maximum displacement.\n    \"\"\"\n    y = y.reshape(-1, 3) - torch.mean(y, dim=0)\n    x = x.reshape(-1, 3) - torch.mean(x, dim=0)\n\n    if align:\n        covariance = x.T @ y\n\n        u, _, vt = torch.linalg.svd(covariance)\n        rotation = torch.matmul(vt.T, u.T)\n\n        if torch.det(rotation) &lt; 0:\n            vt[-1, :] *= -1\n            rotation = torch.matmul(vt.T, u.T)\n\n        y = y @ rotation\n\n    displacement = torch.sqrt(torch.sum((x - y).square(), dim=1))\n\n    rms_disp = torch.sqrt(torch.mean(displacement**2))\n    max_disp = torch.max(displacement)\n\n    return rms_disp, max_disp\n</code></pre>"},{"location":"reference/utils/#tico.utils.brent","title":"brent","text":"<pre><code>brent(\n    fn: Callable[[float, Any], tuple[float, bool]],\n    a: float,\n    b: float,\n    rel: float,\n    cvg: float = 0.1,\n    args: tuple[Any, ...] | None = None,\n) -&gt; tuple[float, list[tuple[float, float, bool]], bool]\n</code></pre> <p>Find the root of a function using Brent's method.</p> <p>The algorithm is considered converged when <code>abs(fs / rel) &lt;= cvg</code>.</p> Notes <p>Based on https://en.wikipedia.org/wiki/Brent (31/01/24).</p> <p>Parameters:</p> <ul> <li> <code>fn</code>             (<code>Callable[[float, Any], tuple[float, bool]]</code>)         \u2013          <p>The function to evaluate.</p> </li> <li> <code>a</code>             (<code>float</code>)         \u2013          <p>The minimum value of the starting bracket.</p> </li> <li> <code>b</code>             (<code>float</code>)         \u2013          <p>The maximum value of the starting bracket.</p> </li> <li> <code>rel</code>             (<code>float</code>)         \u2013          <p>The denominator used to calculate the fractional error.</p> </li> <li> <code>cvg</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>The convergence threshold for the relative error.</p> </li> <li> <code>args</code>             (<code>tuple[Any, ...] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional arguments to pass to the function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, list[tuple[float, float, bool]], bool]</code>         \u2013          <p>The found root, the attempted trials, and whether the algorithm converged.</p> </li> </ul> Source code in <code>tico/utils.py</code> <pre><code>def brent(\n    fn: typing.Callable[[float, typing.Any], tuple[float, bool]],\n    a: float,\n    b: float,\n    rel: float,\n    cvg: float = 0.1,\n    args: tuple[typing.Any, ...] | None = None,\n) -&gt; tuple[float, list[tuple[float, float, bool]], bool]:\n    \"\"\"Find the root of a function using Brent's method.\n\n    The algorithm is considered converged when ``abs(fs / rel) &lt;= cvg``.\n\n    Notes:\n        Based on https://en.wikipedia.org/wiki/Brent (31/01/24).\n\n    Args:\n        fn: The function to evaluate.\n        a: The minimum value of the starting bracket.\n        b: The maximum value of the starting bracket.\n        rel: The denominator used to calculate the fractional error.\n        cvg: The convergence threshold for the relative error.\n        args: Additional arguments to pass to the function.\n\n    Returns:\n        The found root, the attempted trials, and whether the algorithm converged.\n    \"\"\"\n    args = () if args is None else args\n\n    # taken to be constant with geomeTRIC\n    delta, epsilon = 1e-6, min(0.01, 1e-2 * abs(a - b))\n\n    fa, _ = fn(a, *args)\n    fb, _ = fn(b, *args)\n\n    if fa * fb &gt;= 0:\n        raise ValueError(\"values at the bracket endpoints must be of opposite sign\")\n\n    if abs(fa) &lt; abs(fb):\n        a, b = b, a\n        fa, fb = fb, fa\n\n    c, fc, d = a, fa, None\n    mflag = True\n\n    trials = []\n\n    while True:\n        if fa != fc and fb != fc:\n            s = a * fb * fc / ((fa - fb) * (fa - fc))\n            s += b * fa * fc / ((fb - fa) * (fb - fc))\n            s += c * fa * fb / ((fc - fa) * (fc - fb))\n        else:\n            s = b - fb * (b - a) / (fb - fa)\n\n        bound = (3 * a + b) / 4\n\n        condition_1 = not (min(b, bound) &lt; s &lt; max(b, bound))\n        condition_2 = mflag and (abs(s - b) &gt;= abs(b - c) / 2)\n        condition_3 = (not mflag) and (abs(s - b) &gt;= abs(c - d) / 2)\n        condition_4 = mflag and (abs(b - c) &lt; delta)\n        condition_5 = (not mflag) and (abs(c - d) &lt; delta)\n\n        if condition_1 or condition_2 or condition_3 or condition_4 or condition_5:\n            s = (a + b) / 2\n            mflag = True\n        else:\n            mflag = False\n\n        fs, is_valid = fn(s, *args)\n        trials.append((s, fs, is_valid))\n\n        if abs(fs / rel) &lt;= cvg:  # converged\n            return s, trials, True\n        if abs(b - a) &lt; epsilon:  # failed - interval becomes too small\n            return s, trials, False\n\n        d, c = c, b\n        fc = fb\n\n        if fa * fs &lt; 0:\n            b, fb = s, fs\n        else:\n            a, fa = s, fs\n\n        if abs(fa) &lt; abs(fb):\n            a, b = b, a\n            fa, fb = fb, fa\n</code></pre>"}]}